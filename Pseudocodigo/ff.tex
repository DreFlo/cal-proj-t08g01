\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.8in]{geometry} 
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[table,xcdraw]{xcolor}
\usepackage[noend]{algpseudocode}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\begin{document}

\begin{algorithm}[h]
\caption{Knapsack Algorithm - Dynamic Programming}
\begin{algorithmic}[1]


\State $cost \gets M + 1 \text{ lenght array of 0's}$
\State $best \gets M + 1 \text{ lenght array of 0's}$

\Procedure {Knapsack} {M}
\For{i \textbf{from} 1 \text{to} N}
	\For{k \textbf{from} size[i] \text{to} M}
		\If{val[i] + cost[k-size[i]] $>$ cost[k]}
			\State cost[k] = val[i] + cost[k-size[i]]
			\State best[k] = i
		\EndIf
	\EndFor
\EndFor
\EndProcedure

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Floyd-Warshall with path reconstruction}
\begin{algorithmic}[1]

\State $dist \gets  \vert V \vert \times \vert V \vert$ length array of minimum distances initialized to $\infty$
\State $next \gets \vert V \vert \times \vert V \vert$ length array of vertex indices initialized to \textbf{null}

\Procedure {Floyd-Warshall(Path Reconstruction)}{}

\ForEach {\text{edge(u, v)}}
	\State $dist[u][v] \gets w(u, v)$
	\State $next[u][v] \gets v$
\EndFor

\For{$k = 1 to \vert V \vert$}
	\For{$i = 1 to \vert V \vert$}
		\For{$j = 1 to \vert V \vert$}
			\If{$dist[u][v] > dist[i][k] + dist[k][j]$}
				\State $dist[u][v] \gets dist[i][k] + dist[k][j]$
				\State $next[i][j] \gets next[i][k]$
			\EndIf
		\EndFor
	\EndFor
\EndFor

\EndProcedure

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Path reconstruction}
\begin{algorithmic}[1]

\Procedure {GetPath}{u, v}

\If{$next[u][v] = \textbf{null}$}
	\State \textbf{return} $[]$
\EndIf

\State $path = [u]$

\While{$u \neq v$}
	\State $u \gets next[u][v]$
	\State \text{path.append(u)}
\EndWhile

\State \textbf{return} path

\EndProcedure

\end{algorithmic}
\end{algorithm}


\begin{algorithm}[h]
\caption{TSP by Nearest Neighbour}
\begin{algorithmic}[1]

\State V $\gets$ vertices representing all destinations in the route

\Procedure {Nearest Neighbour}{\textbf{Vertex} P}

\State \textbf{queue} sortedVertices $\gets V \setminus \{P\}$
\State result = $[P]$

\While{$\vert sortedVertices \vert > 0$}
	\State sortedVertices.sortRelativeTo(P)
	\State $P \gets sortedVertices.front()$
	\State sortedVertices.pop()
	\State result.append(P)
\EndWhile

\State result.append(result[0])

\State \textbf{return} result
\EndProcedure

\end{algorithmic}
\end{algorithm}

\end{document}