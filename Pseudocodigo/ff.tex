\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.8in]{geometry} 
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[table,xcdraw]{xcolor}
\usepackage[noend]{algpseudocode}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\begin{document}

\begin{algorithm}[h]
\caption{Knapsack Algorithm - Dynamic Programming}
\begin{algorithmic}[1]

\Procedure {Knapsack} {M}

\State $cost \gets M + 1 \text{ lenght array of 0's}$
\State $best \gets M + 1 \text{ lenght array of 0's}$

\For{i \textbf{from} 1 \text{to} N}
	\For{k \textbf{from} size[i] \text{to} M}
		\If{val[i] + cost[k-size[i]] $>$ cost[k]}
			\State cost[k] = val[i] + cost[k-size[i]]
			\State best[k] = i
		\EndIf
	\EndFor
\EndFor

\State print(cost[M])
\For{k \textbf{from} M \text{to} 0 \text{step} size[best[k]]}
	\State print(best[k])
\EndFor

\EndProcedure

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Held-Karp - Dynamic Programming}
\begin{algorithmic}[1]

\Procedure {TSP} {G, n}

\For{k $:=$ 2 \textbf{to} n}
	\State $C(\{k\}, k) := d _{1, k}$
\EndFor

\For{s $:=$ \textbf{to} n - 1}
	\For{\textbf{all} S $\subseteq \{2, ..., n\}, |S| = s$}
		\For{\textbf{all} $k \in S$}
			\State C(S, k) := $min_{m \neq k, m \in S}$ [C(S\\\{k\}, m + $d_{m, k}$]
		\EndFor
	\EndFor
\EndFor

\State \textbf{return}  $min_{k \neq 1} [C(\{2, ..., n\}, k) + d_{k, 1}]$

\EndProcedure

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Floyd-Warshall with path reconstruction}
\begin{algorithmic}[1]

\State \textbf{let} dist be a $\vert V \vert \times \vert V \vert$ array of minimum distances initialized to $\infty$
\State \textbf{let} next be a $\vert V \vert \times \vert V \vert$ array of vertex indices initialized to \textbf{null}

\Procedure {Floyd-Warshall(Path Recontruction)}{}

\ForEach {\text{edge(u, v)}}
	\State $dist[u][v] \gets w(u, v)$
	\State $next[u][v] \gets v$
\EndFor

\For{$k = 1 to \vert V \vert$}
	\For{$i = 1 to \vert V \vert$}
		\For{$j = 1 to \vert V \vert$}
			\If{$dist[u][v] > dist[i][k] + dist[k][j]$}
				\State $dist[u][v] \gets dist[i][k] + dist[k][j]$
				\State $next[i][j] \gets next[i][k]$
			\EndIf
		\EndFor
	\EndFor
\EndFor

\EndProcedure

\Procedure {GetPath}{u, v}

\If{$next[u][v] = \textbf{null}$}
	\State \textbf{return} $[]$
\EndIf

\State $path = [u]$

\While{$u \neq v$}
	\State $u \gets next[u][v]$
	\State \text{path.append(u)}
\EndWhile

\State \textbf{return} path

\EndProcedure

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Nearest Neighbour}
\begin{algorithmic}[1]
\Procedure {Nearest Neighbour}{\textbf{Vertex} P}

\State \textbf{queue} nodesSorted
\State result = $[]$
\State $V _{t} \gets V$

\While{$\vert V _{t} \vert > 0$}
	\State nodesSorted.resortRelativeTo(P)
	\State result.append(P)
	\State $P \gets result[0]$
	\State nodesSort.removeTop()
\EndWhile

\State \textbf{return} result
\EndProcedure

\end{algorithmic}
\end{algorithm}

\end{document}